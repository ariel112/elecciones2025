<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Monitoreo Electoral Local</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f0f4f8;
        }
        .card {
            background-color: white;
            border-radius: 1rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
        }
        .header-bg {
            background-image: linear-gradient(to right, #004d99, #007bff);
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
    <script>
        // --- VARIABLES GLOBALES Y CONFIGURACIÓN ---
        let currentIntervalId = null;
        const POLLING_INTERVAL_STORAGE_KEY = 'pollingIntervalMinutes';
        const HISTORY_STORAGE_KEY = 'electionResultsHistory'; // Clave para localStorage
        
        // Definición de Candidatos a Rastrear
        const CANDIDATE_TRACKING = [
            { id: '1', nombre: 'SALVADOR NASRRALLA', color: '#10B981', foto: 'https://placehold.co/100x100/10B981/ffffff?text=SN' },
            { id: '2', nombre: 'NASRY JUAN ASZURA ZABLAH', color: '#EF4444', foto: 'https://placehold.co/100x100/EF4444/ffffff?text=NA' },
            { id: '3', nombre: 'RIXI RAMONA MONCADA GODOY', color: '#f97316', foto: 'https://placehold.co/100x100/f97316/ffffff?text=RM' },
            { id: '4', nombre: 'OTROS CANDIDATOS', color: '#3B82F6', foto: 'https://placehold.co/100x100/3B82F6/ffffff?text=OC' },
        ];
        
        // La ruta de la API y el payload (cuerpo de la petición POST)
        const API_URL = 'https://resultadosgenerales2025-api.cne.hn/esc/v1/presentacion-resultados';
        const API_PAYLOAD = {
            "codigos": [], "tipco": "01", "depto": "00", "comuna": "00", "mcpio": "000", "zona": "", "pesto": "", "mesa": 0
        };

        // Gráficos globales
        let barChartInstance, growthChartInstance;

        // --- 1. Inicialización y Carga ---

        function initializeApp() {
            // No se necesita Firebase, solo cargamos la configuración local
            loadIntervalAndStartPolling();
            loadAndDisplayResults(); 
        }

        // --- 2. Funciones de API y Almacenamiento Local ---
        
        /**
         * Llama a la API de resultados electorales o ejecuta la simulación si es necesario.
         * @returns {Object} Datos de la API procesados o simulados.
         */
        async function fetchApiResults() {
            try {
                document.getElementById('status').textContent = 'Consultando API...';
                
                const isLocalFile = window.location.protocol === 'file:';

                if (isLocalFile) {
                    // Si es archivo local, siempre usamos la simulación
                    document.getElementById('status').textContent = 'Modo Simulación Activo.';
                    return fetchApiResultsSimulated();
                }

                // --- LÓGICA DE API REAL ---
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(API_PAYLOAD)
                });

                if (!response.ok) {
                    throw new Error(`Error HTTP: ${response.status}. Recurriendo a simulación.`);
                }

                const rawData = await response.json();
                
                const candidatesList = rawData.candidatos || rawData.resultados || rawData.results || [];
                let totalVotos = 0;
                const candidateVotes = {};
                console.log('candidatesList: ', candidatesList);
                candidatesList.forEach(c => {
                    const candidateName = c.nombre || ''; 
                    const votes = parseInt(c.votos, 10) || 0;
                    totalVotos += votes;

                    const trackedCandidate = CANDIDATE_TRACKING.find(t => t.nombre === candidateName);
                    
                    if (trackedCandidate) {
                        candidateVotes[candidateName] = votes;
                    } 
                });
                console.log('CANDIDATE_TRACKING API: ', CANDIDATE_TRACKING);
                const processedCandidates = CANDIDATE_TRACKING.map(t => {
                    const votos = candidateVotes[t.nombre] || 0;
                    return {
                        nombre: t.nombre,
                        votos: votos,
                        porcentaje: (totalVotos > 0 ? (votos / totalVotos * 100) : 0).toFixed(2)
                    };
                }).filter(c => c.votos > 0);
                console.log('processedCandidates api: ', processedCandidates);
                document.getElementById('status').textContent = 'Última consulta de API exitosa.';
                return { 
                    data: candidateVotes, 
                    totalVotos,
                    processedCandidates,
                    timestamp: new Date().toISOString() // Se guarda como ISO string
                };

            } catch (error) {
                console.error("Error al obtener datos de la API (usando simulación):", error);
                document.getElementById('status').textContent = `Error API: ${error.message}. Usando Modo Simulación.`;
                // Si la API falla, recurrimos a la simulación para tener datos de crecimiento
                return fetchApiResultsSimulated();
            }
        }
        
        /**
         * Genera datos de votación simulados con crecimiento gradual.
         * @returns {Object} Datos simulados procesados.
         */
        function fetchApiResultsSimulated() {
            const latestData = getLatestStoredResults(true); // Obtener el último con formato de datos
            
            // Usamos los valores del último registro (o valores de base inicial si no hay historial)
            const baseVotes = latestData ? latestData.data : {
                 'SALVADOR NASRRALLA': 1018320, 
                 'NASRY JUAN ASZURA ZABLAH': 999441, 
                 'RIXI RAMONA MONCADA GODOY': 480203,
                 'OTROS CANDIDATOS': 0
            };
            
            const mockResults = [];
            let totalVotos = 0;

            CANDIDATE_TRACKING.forEach(c => {
                const currentVotes = baseVotes[c.nombre] || 0; 
                let newVotes;
                
                if (c.nombre !== 'OTROS CANDIDATOS') {
                    // Factor de crecimiento pequeño (0.0% a 0.5% + un número aleatorio)
                    const factor = Math.random() * 0.005 + 1; 
                    newVotes = Math.round(currentVotes * factor) + Math.floor(Math.random() * 5000);
                } else {
                    newVotes = 0; 
                }
                
                mockResults.push({ nombre: c.nombre, votos: newVotes });
                totalVotos += newVotes;
            });
            
            const candidateVotes = mockResults.reduce((acc, c) => {
                acc[c.nombre] = c.votos;
                return acc;
            }, {});

            const processedCandidates = mockResults.map(c => ({
                ...c,
                porcentaje: (totalVotos > 0 ? (c.votos / totalVotos * 100) : 0).toFixed(2)
            }));

            return {
                data: candidateVotes,
                totalVotos: totalVotos,
                processedCandidates: processedCandidates,
                timestamp: new Date().toISOString() // Se guarda como ISO string
            };
        }

        /**
         * Carga el historial de resultados desde localStorage y convierte los timestamps a Date.
         * @returns {Object[]} El historial completo o un array vacío.
         */
        function loadHistory() {
            try {
                const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
                if (!historyJson) return [];
                
                const history = JSON.parse(historyJson);
                
                // Revertir el timestamp de ISO string a objeto Date para su uso posterior
                return history.map(h => ({
                    ...h,
                    timestamp: new Date(h.timestamp)
                }));
            } catch (e) {
                console.error("Error al cargar historial de localStorage:", e);
                return [];
            }
        }

        /**
         * Obtiene el último registro guardado en localStorage.
         * @param {boolean} [returnSerializable=false] Si es true, retorna la versión no convertida de Date.
         */
        function getLatestStoredResults(returnSerializable = false) {
             const history = returnSerializable ? loadRawHistory() : loadHistory();
             if (history.length > 0) {
                 return history[history.length - 1];
             }
             return null;
        }

        /**
         * Carga el historial sin convertir el timestamp para propósitos de serialización.
         */
        function loadRawHistory() {
            try {
                 const historyJson = localStorage.getItem(HISTORY_STORAGE_KEY);
                 return historyJson ? JSON.parse(historyJson) : [];
            } catch (e) {
                 return [];
            }
        }

        /**
         * Agrega el nuevo resultado al historial y lo guarda en localStorage.
         * @param {Object} results Los resultados procesados a guardar (con timestamp ISO string).
         */
        function saveResults(results) {
            if (!results) {
                console.warn("No se pueden guardar resultados nulos.");
                return;
            }
            try {
                // Cargamos el historial en formato RAW (sin convertir a Date) para agregarlo
                let history = loadRawHistory();
                
                // Agregamos el nuevo registro que ya tiene el timestamp como ISO string
                history.push(results);
                
                localStorage.setItem(HISTORY_STORAGE_KEY, JSON.stringify(history));
                console.log("Resultados guardados en localStorage.");
                document.getElementById('status').textContent = `Datos actualizados a las ${new Date().toLocaleTimeString('es-HN')}`;
                
            } catch (error) {
                console.error("Error al guardar en localStorage:", error);
                document.getElementById('status').textContent = 'Error al guardar en el navegador.';
            }
        }
        
        /**
         * Carga el historial completo y actualiza el dashboard.
         */
        function loadAndDisplayResults() {
            // La función loadHistory ya convierte los timestamps a Date
            const allResults = loadHistory(); 
            updateDashboard(allResults);
        }

        // --- 3. Lógica de Polling y Configuración ---

        function loadIntervalAndStartPolling() {
            const storedInterval = localStorage.getItem(POLLING_INTERVAL_STORAGE_KEY);
            const defaultInterval = 20; // 20 minutos por defecto
            const intervalMinutes = storedInterval ? parseInt(storedInterval, 10) : defaultInterval;

            document.getElementById('polling-interval').value = intervalMinutes;
            startPolling(intervalMinutes);

            // Manejador del botón de configuración
            document.getElementById('save-config-btn').addEventListener('click', () => {
                const newInterval = parseInt(document.getElementById('polling-interval').value, 10);
                if (newInterval >= 1) {
                    localStorage.setItem(POLLING_INTERVAL_STORAGE_KEY, newInterval);
                    startPolling(newInterval);
                    showMessage('Intervalo de consulta actualizado a ' + newInterval + ' minutos.', 'success');
                } else {
                    showMessage('El intervalo debe ser al menos 1 minuto.', 'error');
                }
            });
            
             // Manejador del botón de limpieza
            document.getElementById('clear-history-btn').addEventListener('click', () => {
                localStorage.removeItem(HISTORY_STORAGE_KEY);
                loadAndDisplayResults();
                showMessage('Historial de resultados limpiado.', 'success');
                 // Reiniciar el polling
                loadIntervalAndStartPolling(); 
            });
        }

        /**
         * Inicia el proceso de consulta a la API y lo programa con el intervalo dado.
         * @param {number} minutes El intervalo en minutos.
         */
        function startPolling(minutes) {
            if (currentIntervalId) {
                clearInterval(currentIntervalId);
            }

            const ms = minutes * 60 * 1000;
            const pollingFn = async () => {
                const results = await fetchApiResults();
                if (results) {
                    saveResults(results);
                    loadAndDisplayResults(); // Recargar y mostrar
                }
                document.getElementById('last-update').textContent = `Última consulta: ${new Date().toLocaleTimeString('es-HN')}`;
            };

            // Ejecutar inmediatamente y luego en el intervalo
            pollingFn(); 
            currentIntervalId = setInterval(pollingFn, ms);
            document.getElementById('interval-display').textContent = `${minutes} minutos`;
        }


        // --- 4. Funciones de Gráficas y Dashboard ---

        /**
         * Dibuja y actualiza la gráfica de barras de los resultados actuales.
         */
        function updateBarChart(latestCandidates) {
            // ... (El código de updateBarChart se mantiene igual) ...
            const labels = latestCandidates.map(c => c.nombre);
            const votes = latestCandidates.map(c => c.votos);
            const colors = latestCandidates.map(c => CANDIDATE_TRACKING.find(t => t.nombre === c.nombre)?.color || '#9CA3AF');
            
            const ctx = document.getElementById('barChart').getContext('2d');

            if (barChartInstance) {
                barChartInstance.data.labels = labels;
                barChartInstance.data.datasets[0].data = votes;
                barChartInstance.data.datasets[0].backgroundColor = colors;
                barChartInstance.update();
            } else {
                barChartInstance = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Votos Actuales',
                            data: votes,
                            backgroundColor: colors,
                            borderRadius: 6,
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: { display: false },
                            title: { display: true, text: 'Resultados Actuales por Votos', font: { size: 16 } }
                        },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Número de Votos' } }
                        }
                    }
                });
            }
        }

        /**
         * Dibuja y actualiza la gráfica de crecimiento histórico (Línea).
         * @param {Object[]} history Todos los resultados históricos (con timestamp como Date).
         */
        function updateGrowthChart(history) {
            // Aquí usamos el objeto Date directamente
            const labels = history.map(h => h.timestamp.toLocaleTimeString('es-HN', { hour: '2-digit', minute: '2-digit' }));
            
            // Filtramos explícitamente solo los dos candidatos solicitados (Nasrralla y Aszura)
            const candidatesToTrack = ['SALVADOR NASRRALLA', 'NASRY JUAN ASZURA ZABLAH'];

            const datasets = CANDIDATE_TRACKING
                .filter(c => candidatesToTrack.includes(c.nombre))
                .map(candidate => {
                    const dataPoints = history.map(h => h.data[candidate.nombre] || 0); // Votos en cada punto histórico
                    return {
                        label: candidate.nombre,
                        data: dataPoints,
                        borderColor: candidate.color,
                        backgroundColor: candidate.color + '33', // Color con transparencia
                        fill: true,
                        tension: 0.3,
                        pointRadius: 3,
                    };
                });

            const ctx = document.getElementById('growthChart').getContext('2d');

            if (growthChartInstance) {
                growthChartInstance.data.labels = labels;
                growthChartInstance.data.datasets = datasets;
                growthChartInstance.update();
            } else {
                growthChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: datasets
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            title: { display: true, text: 'Crecimiento Histórico de Votos', font: { size: 16 } }
                        },
                        scales: {
                            y: { beginAtZero: true, title: { display: true, text: 'Votos Acumulados' } },
                            x: { title: { display: true, text: 'Hora de Consulta' } }
                        }
                    }
                });
            }
        }
        
        /**
         * Actualiza todos los componentes del dashboard.
         * @param {Object[]} allResults Todos los resultados históricos.
         */
        function updateDashboard(allResults) {
            if (allResults.length === 0) {
                 document.getElementById('latest-results-cards').innerHTML = '<p class="text-gray-500 p-4">Aún no hay datos históricos. El dashboard se actualizará después de la primera consulta.</p>';
                 document.getElementById('total-votes-display').textContent = '';
                 
                 // Destruir gráficos si existen para evitar errores
                 if (barChartInstance) { barChartInstance.destroy(); barChartInstance = null; }
                 if (growthChartInstance) { growthChartInstance.destroy(); growthChartInstance = null; }
                 return;
            }
            
            // 1. Datos actuales para el Bar Chart y Tarjetas (el último registro)
            const latestRecord = allResults[allResults.length - 1];
            console.log('CANDIDATE_TRACKING dass: ', CANDIDATE_TRACKING);
            // Recalculamos el porcentaje basado en el total de votos del registro
            const latestCandidatesData = CANDIDATE_TRACKING.map(t => {
                const votos = latestRecord.data[t.nombre] || 0;
                return {
                    ...t,
                    votos: votos,
                    porcentaje: (latestRecord.totalVotos > 0 ? (votos / latestRecord.totalVotos * 100) : 0).toFixed(2)
                };
            }).filter(c => c.votos > 0).sort((a, b) => b.votos - a.votos);

            console.log('latestCandidatesData: ', latestCandidatesData);

            updateBarChart(latestCandidatesData);
            
            // 2. Tarjetas de Candidatos
            let cardsHtml = '';
            latestCandidatesData.forEach(c => {
                cardsHtml += `
                    <div class="card p-4 flex items-center space-x-4 border-l-4" style="border-left-color: ${c.color};">
                        <img src="${c.foto}" alt="Foto de ${c.nombre}" class="w-16 h-16 rounded-full object-cover">
                        <div class="flex-grow">
                            <p class="text-sm font-semibold text-gray-700">${c.nombre}</p>
                            <p class="text-2xl font-bold" style="color: ${c.color};">${c.votos.toLocaleString('es-HN')}</p>
                            <div class="w-full bg-gray-200 rounded-full h-2.5 mt-1">
                                <div class="h-2.5 rounded-full" style="width: ${c.porcentaje}%; background-color: ${c.color};"></div>
                            </div>
                        </div>
                        <span class="text-xl font-extrabold text-gray-700">${c.porcentaje}%</span>
                    </div>
                `;
            });
            document.getElementById('latest-results-cards').innerHTML = cardsHtml;
            document.getElementById('total-votes-display').textContent = `Total de Votos Reportados: ${latestRecord.totalVotos.toLocaleString('es-HN')}`;

            // 3. Gráfica de Crecimiento
            updateGrowthChart(allResults);
        }

        // Función para mostrar mensajes temporales
        function showMessage(message, type) {
            const msgEl = document.getElementById('message-box');
            msgEl.textContent = message;
            msgEl.className = 'text-center p-2 rounded-lg mt-4';
            if (type === 'success') {
                msgEl.classList.add('bg-green-100', 'text-green-800');
            } else if (type === 'error') {
                msgEl.classList.add('bg-red-100', 'text-red-800');
            }
            setTimeout(() => { msgEl.textContent = ''; msgEl.className = ''; }, 5000);
        }


        // Iniciar la aplicación al cargar la ventana
        window.onload = initializeApp;
    </script>
</head>
<body>
    <div class="min-h-screen">
        <header class="header-bg text-white shadow-lg p-4 sm:p-6">
            <h1 class="text-2xl sm:text-3xl font-bold">Dashboard Electoral Local</h1>
            <p class="text-sm opacity-80 mt-1">Monitoreo y Crecimiento Histórico de Resultados</p>
            <p class="text-xs mt-2 italic text-yellow-300">Modo Local: Los datos se simulan y se guardan en el almacenamiento de su navegador.</p>
        </header>

        <main class="container mx-auto p-4 sm:p-6 lg:p-8">
            <section class="mb-8 p-4 card md:flex md:justify-between md:items-center">
                <div class="mb-4 md:mb-0">
                    <h2 class="text-xl font-semibold text-gray-800">Estado y Configuración de Polling</h2>
                    <p id="status" class="text-sm text-blue-600 mt-1">Cargando configuración...</p>
                    <p id="last-update" class="text-xs text-gray-500 mt-1">Última consulta: Nunca</p>
                    <p class="text-xs text-gray-500">Intervalo de consulta: <span id="interval-display" class="font-bold">20 minutos</span></p>
                    <div id="message-box"></div>
                </div>

                <div class="flex flex-col sm:flex-row items-start sm:items-end space-y-2 sm:space-y-0 sm:space-x-4">
                    <div class="w-full sm:w-auto">
                        <label for="polling-interval" class="block text-sm font-medium text-gray-700 whitespace-nowrap">Intervalo (minutos):</label>
                        <input type="number" id="polling-interval" value="20" min="1" class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-blue-500 focus:ring-blue-500 p-2 border">
                    </div>
                    <button id="save-config-btn" class="w-full sm:w-auto mt-6 sm:mt-0 px-4 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition duration-150">
                        Guardar y Reiniciar
                    </button>
                    <button id="clear-history-btn" class="w-full sm:w-auto mt-6 sm:mt-0 px-4 py-2 bg-red-600 text-white font-semibold rounded-lg shadow-md hover:bg-red-700 transition duration-150">
                        Limpiar Historial
                    </button>
                </div>
            </section>

            <h2 id="total-votes-display" class="text-lg font-bold text-gray-700 mb-4"></h2>
            
            <section id="latest-results-cards" class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
                </section>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8">
                <div class="card p-4 min-h-[400px]">
                    <div class="h-full">
                        <canvas id="barChart"></canvas>
                    </div>
                </div>

                <div class="card p-4 min-h-[400px]">
                    <div class="h-full">
                        <canvas id="growthChart"></canvas>
                    </div>
                </div>
            </div>
        </main>

        <footer class="text-center p-4 text-sm text-gray-500">
            Desarrollado con localStorage y Chart.js.
        </footer>
    </div>
</body>
